// Code generated by github.com/turscar/sqlcmock DO NOT EDIT.

package {{ .GenPackage }}

{{ with .Imports }}
import (
{{ range . }}
    {{ with .Name }}{{ . }} }}{{ end }}"{{ .Path }}"{{ end }}
)
{{ end }}

import (
    "github.com/google/go-cmp/cmp"
    "testing"
    "github.com/sanity-io/litter"
    "reflect"
    "fmt"
    "{{ .ModelPath }}"
)

var _ {{ .Package }}.Querier = (*{{ .Struct }})(nil)

type Operation interface {
    OpName() string
    Values() Operation
    Compare(t testing.TB, want, got Operation)
}

type {{ .Struct }} struct {
    T testing.TB
    Expected []Operation
}

{{ range .Methods }}
func (m *{{ $.Struct }}) {{ .Name }}({{ range $i, $v := .Input }}{{ if ne $i 0 }}, {{ end }}{{ $v.Name }} {{ $v.Type }}{{ end }}) ({{ range $i, $v := .Output }}{{ if ne $i 0 }}, {{ end }}{{ $v.Type }}{{ end }}) {
    m.T.Helper()
    if len(m.Expected) == 0 {
        m.T.Logf("{{ lcfirst .Name }}{\n{{ range rest .Input }}  {{ ucfirst .Name }}: %s\n{{ end }}}\n"{{ range rest .Input }}, litter.Sdump({{ .Name }}){{ end }})
        m.T.Fatalf("Request for {{ .Name }} but no operations left")
    }

    if m.Expected[0].OpName() != "{{ .Name }}" {
        m.T.Logf("{{ .Name }}{\n{{ range rest .Input }}  {{ ucfirst .Name }}: %s\n{{ end }}}\n"{{ range rest .Input }}, litter.Sdump({{ .Name }}){{ end }})
        m.T.Fatalf("Got request for {{ .Name }}, expected %s", m.Expected[0].OpName());
    }
    v, ok := m.Expected[0].Values().({{ .Name }})
    if !ok {
      m.T.Fatalf("{{ .Name }} of type %T returned values of type %T", m.Expected[0], m.Expected[0].Values())
    }

    got := {{ .Name }} {
{{ range rest .Input }}
    {{ ucfirst .Name }}: {{ .Name }},
    {{ end }}
    }
    want := {{ .Name }} {
        {{ range rest .Input }}
            {{ ucfirst .Name }}: v.{{ ucfirst .Name }},
        {{ end }}
    }
    m.Expected[0].Compare(m.T, want, got)

    m.Expected = m.Expected[1:]

    return {{ range $i, $v := .Output }}{{ if ne $i 0 }}, {{ end }}v.{{ if eq .Type "error" }}Err{{ else }}Result{{ with $i }}{{ . }}{{ end }}{{ end }}{{ end }}
}
{{ end }}

{{ range .Methods }}
type {{ .Name }} struct {
  {{ range rest .Input }}
  {{ ucfirst .Name }} {{ .Type }}{{ end }}
  {{ range $i, $v := .Output }}
  {{ if eq .Type "error" }}Err{{ else }}Result{{ with $i }}{{ . }}{{ end }}{{ end }} {{ .Type }}{{ end }}
}

func ({{ .Name }}) OpName() string {
  return "{{ .Name }}"
}

func (o {{ .Name }}) Compare(t testing.TB, want, got Operation) {
    t.Helper()
    _, ok := got.({{ .Name }})
    if !ok {
       t.Fatalf("Compare for {{ .Name }} called with %T", got)
    }

    diff := cmp.Diff(want, got)
    if diff != "" {
      t.Errorf("{{ .Name }} mismatch (-want +got):\n%s", diff)
    }

}

func (o {{ .Name }}) Values() Operation {
    return o
    }
{{ end }}

func Add(m *{{ .Struct }}, args ...any) {
  for _, arg := range args {
    switch reflect.TypeOf(arg).Kind() {
    case reflect.Slice:
      s := reflect.ValueOf(arg)
      for i := 0; i < s.Len(); i++ {
        Add(m, s.Index(i).Interface())
      }
      continue
    }

    switch v := arg.(type) {
      case Operation:
        m.Expected = append(m.Expected, v)
      default:
        panic(fmt.Sprintf("Unexpected type added to mock: %T", arg))
     }
  }

}
